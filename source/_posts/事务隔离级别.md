---
title: 事务隔离级别
date: 2018-11-12 14:23:01
tags: 事务
---

# MySQL--事务（Transaction）

### 一、事务的基本要素（ACID）

* **原子性**（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就想没有发生一样。也就是说事务是一个不可分割的整体。
* **一致性**（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没有收到。
* **隔离性**（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程中，B不能向这张卡转账。
* **持久性**（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。



### 二、事务的并发问题

* **脏读**：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据。
* **不可重复读**：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。
* **幻读**：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。

**小结**：不可重复读和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增和删除。解决不可重复读的问题只需要锁住满足条件的行，解决幻读需要锁表。



### 三、MySQL事务隔离级别

|         事务隔离级别         | 脏读 | 不可重复读 |         幻读          |
| :--------------------------: | :--: | :--------: | :-------------------: |
| 读未提交（read uncommitted） |  是  |     是     |          是           |
|  读已提交（read committed）  |  否  |     是     |          是           |
| 可重复读（repeatable read）  |  否  |     否     | 是（mysql-InnoDB 否） |
|    串性化（serializable）    |  否  |     否     |          否           |

* read uncommitted：

``` bash
- 事务A和事务B，事务A未提交的数据，事务B可以读取到
- 这里读取到的数据叫做“脏数据”
- 这种隔离级别最低，这种级别一般是在理论上存在，数据库隔离级别一般都高于该级别
```

* read committed：

```bash
- 事物A和事物B，事物A提交的数据，事物B才能读取到
- 这种隔离级别高于读未提交
- 换句话说，对方事物提交之后的数据，我当前事物才能读取到
- 这种级别可以避免“脏数据”
- 这种隔离级别会导致“不可重复读取”
- Oracle默认隔离级别
```

* repeatable read：

```bash
- 事务A和事务B，事务A提交之后的数据，事务B读取不到
- 事务B是可重复读取数据
- 这种隔离级别高于读已提交
- 换句话说，对方提交之后的数据，我还是读取不到
- 这种隔离级别可以避免“不可重复读取”，达到可重复读取
- 比如1点和2点读到数据是同一个
- MySQL默认级别
- 虽然可以达到可重复读取，但是会导致“幻像读”
- 可重复读的隔离级别下使用了MVCC机制，select操作不会更新版本号，是快照读（历史版本）；insert、update和delete会更新版本号，是当前读（当前版本）。
```

* serializable：

```bash
- 事务A和事务B，事务A在操作数据库时，事务B只能排队等待
- 这种隔离级别很少使用，吞吐量太低，用户体验差
- 这种级别可以避免“幻像读”，每一次读取的都是数据库中真实存在数据，事务A与事务B串行，而不并发
```



### 四、基本操作

```bash
- 查询当前事务级别
mysql> select @@tx_isolation;
- 设置隔离级别
SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL <isolation-level>
```



### 五、补充

* 事务隔离级别为读提交时，写数据只会锁住相应的行

* 事务隔离级别为可重复读时，如果检索条件有索引（包括主键索引）的时候，默认加锁方式是next-key锁；如果检索条件没有索引，更新数据时会锁住整张表。一个间隙被事务加了锁，其他事务是不能在这个间隙插入记录的，这样可以防止幻读。

* 事务隔离级别为串行化时，读写数据都会锁住整张表。

* 隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。

* [MySQL MVCCC实现机制](https://blog.csdn.net/whoamiyang/article/details/51901888 )

* [关于next-key锁](https://blog.csdn.net/bigtree_3721/article/details/73731377 )

  

  

  

  

  

  

  













































































































































































































