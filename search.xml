<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[markdown-整理]]></title>
    <url>%2F2018%2F12%2F24%2Fmarkdown-%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Markdown – 整理一 、标题1234567891011121. 最高阶标题This is an H1=============2. 第二阶标题This is an H2-------------3. 用#表示阶数（只有1-6阶）# 这是 H1## 这是 H2###### 这是 H6 1. This is an H12. This is an H23. 这是 H1这是 H2这是 H6 二 、引用1234567891011&gt;这是引用&gt;引用名人名言之类的呀&gt;&gt;也可以嵌套引用&gt; ## 这是一个标题。&gt;&gt; 1. 这是第一行列表项。&gt; 2. 这是第二行列表项。&gt;&gt; 给出一些例子代码：&gt;&gt; return shell_exec("echo $input | $markdown_script"); 这是引用引用名人名言之类的呀 也可以嵌套引用 这是一个标题。 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(&quot;echo $input | $markdown_script&quot;); 三 、列表12345678910111213141516171819* Red - asd - ead - sada - asd* Green* Blue1. Bird 1. sadaasd 中间也可以插入其他标签 2. sadaasd 3. asdas 4. asdas 1. asdas 2. asdas2. McHale3. Parish Red asd ead sada asd Green Blue Bird sadaasd 1中间也可以插入其他标签 sadaasd asdas asdas asdas asdas McHale Parish 四 、分隔线123456789* * *********- - ---------------------------------------- 五 、 链接/图片123456789101112131415161718This is [an example](http://example.com/ "Title") inline link.[This link](http://example.net/) has no title attribute.[foo]: http://example.com/ "Optional Title Here"[自定义链接] [id][id]: http://example.com/ "Optional Title Here"![Alt text](/markdown-整理/img.png)![Alt text](/markdown-整理/img.png "Optional title")![Alt text][idpig][idpig]: /markdown-整理/img.pnge "Optional title attribute" This is an example inline link. This link has no title attribute. 自定义链接 六 、 强调123456789*single asterisks***double asterisks*****three asterisks***\*this text is surrounded by literal asterisks\*~~这样~~ single asterisks double asterisks three asterisks *this text is surrounded by literal asterisks* 这样 七 、 代码123456789Use the `printf()` function.``There is a literal backtick (`) here.``A single backtick in a code span: `` ` ``A backtick-delimited string in a code span: `` `foo` ``Please don't use any `&lt;blink&gt;` tags. Use the printf() function. There is a literal backtick (`) here. A single backtick in a code span: ` A backtick-delimited string in a code span: `foo` Please don’t use any &lt;blink&gt; tags. 八 、 选项123- [x] 这是选中的复选框` ‘-’ + ‘空格’ + ‘[中间有空格]’ `- [ ] 这是未选中的复选框` ‘-’ + ‘空格’ + ‘[中间有空格]’ ` [x] 这是选中的复选框‘-’ + ‘空格’ + ‘[中间有空格]’ [ ] 这是未选中的复选框‘-’ + ‘空格’ + ‘[中间有空格]’ 九 、 表格1234| a | b | c ||:-------:|:------------- | ----------:|| 居中 | 左对齐 | 右对齐 ||=========|===============|============| a b c 居中 左对齐 右对齐 ========= =============== ============ 十 、 不兼容的12345678# 脚注 Footnote这就是一个脚注:[^sample_footnote]# MarkDown的标注&lt;!-- comment --&gt;# 自动生成目录 TOC[TOC]]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 整理]]></title>
    <url>%2F2018%2F11%2F30%2FLinux-%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[命令行网站]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven 整理]]></title>
    <url>%2F2018%2F11%2F30%2FMaven-%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[坐标与依赖 了能够自动化地解析任何一个Java构件, Maven必须将它们唯一标识, 这就是依赖管理的底层基础-坐标. 1234&lt;groupId&gt;org.apache.commons&lt;/groupId&gt;&lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;&lt;version&gt;3.4&lt;/version&gt;&lt;packaging&gt;jar&lt;/packaging&gt; 元素 描述 ext groupId 定义当前模块隶属的实际Maven项目, 表示方式与Java包类似 groupId不应直接对应项目隶属的公司/组织(一个公司/组织下可能会有很多的项目) artifactId 定义实际项目中的一个Maven模块 推荐使用项目名作为artifactId前缀, 如:commons-lang3以commons作为前缀(因为Maven打包默认以artifactId作为前缀) version 定义当前项目所处版本(如1.0-SNAPSHOT、4.2.7.RELEASE、1.2.15、14.0.1-h-3 等) Maven版本号定义约定: &lt;主版本&gt;.&lt;次版本&gt;.&lt;增量版本&gt;-&lt;里程碑版本&gt; packaging 定义Maven项目打包方式, 通常打包方式与所生成构件扩展名对应 有jar(默认)、war、pom、maven-plugin等. classifier 用来帮助定义构建输出的一些附属构件(如javadoc、sources) 不能直接定义项目的classifier(因为附属构件不是由项目默认生成, 须有附加插件的帮助) 依赖调节原则: 1. 路径最近者优先; 2. 第一声明者优先.更多传递依赖信息可参考:Dependency Mechanism-Transitive Dependencies. 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.2.7.RELEASE&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;optional&gt;false&lt;/optional&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 元素 描述 ext groupId、artifactId和version 依赖的基本坐标(最最重要) type 依赖的类型, 对应于项目坐标定义的packaging 默认jar scope 依赖的范围, 用来控制依赖与三种classpath(编译classpath、测试classpath、运行classpath)的关系 包含compile、provided、runtime、test、system和import 6种 详见:Dependency Scope optional 依赖是否可选 假如一个Jar包支持MySQL与Oracle两种DB, 因此其构建时必须添加两类驱动, 但用户使用时只会选择一种DB. 此时对A、B就可使用optional可选依赖 exclusions 排除传递性依赖 传递性依赖极大的简化了项目依赖的管理, 但也会引入Jar包版本冲突等问题, 此时就需要对传递性依赖进行排除.optional与exclusions详细可参考: Optional Dependencies and Dependency Exclusions 依赖管理 Maven提供了dependency插件可以对Maven项目依赖查看以及优化, 如$ mvn dependency:tree可以查看当前项目的依赖树, 详见$ mvn dependency:help 依赖范围scope用来控制依赖和编译，测试，运行的classpath的关系. 主要的是三种依赖关系如下： compile： 编译依赖范围。如果没有指定，就会默认使用该依赖范围。使用此依赖范围的Maven依赖，对于编译、测试、运行三种classpath都有效。典型的例子是spring-code,在编译、测试和运行的时候都需要使用该依赖。 test：测试依赖范围。使用次依赖范围的Maven依赖，只对于测试classpath有效，在编译主代码或者运行项目的使用时将无法使用此依赖。典型的例子是Jnuit,它只有在编译测试代码及运行测试的时候才需要。 provided：已提供依赖范围。使用此依赖范围的Maven依赖，对于编译和测试classpath有效，但在运行时候无效。典型的例子是servlet-api,编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器以及提供，就不需要Maven重复地引入一遍。 runtime:运行时依赖范围。使用此依赖范围的Maven依赖，对于测试和运行classpath有效，但在编译主代码时无效。典型的例子是JDBC驱动实现，项目主代码的编译只需要JDK提供的JDBC接口，只有在执行测试或者运行项目的时候才需要实现上述接口的具体JDBC驱动。 system:系统依赖范围。该依赖与三种classpath的关系，和provided依赖范围完全一致，但是，使用system范围的依赖时必须通过systemPath元素显示地指定依赖文件的路径。由于此类依赖不是通过Maven仓库解析的，而且往往与本机系统绑定，可能构成构建的不可移植，因此应该谨慎使用。systemPath元素可以引用环境变量，如： 1234567&lt;dependency&gt; &lt;groupId&gt;javax.sql&lt;/groupId&gt; &lt;artifactId&gt;jdbc-stdext&lt;/artifactId&gt; &lt;Version&gt;2.0&lt;/Version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;$&#123;java.home&#125;/lib/rt.jar&lt;/systemPath&gt;&lt;/dependency&gt; import:导入依赖范围。该依赖范围不会对三种classpath产生实际的影响。上述除import以外的各种依赖范围与三种classpath的关系如下: 仓库 Maven 中, 任何一个依赖、插件或项目构建的输出, 都可称为构件, 而Maven仓库就是集中存储这些构件的地方. Maven仓库可简单分成两类: 本地仓库与远程仓库. 当Maven根据坐标寻找构件时, 它会首先检索本地仓库, 如果本地存在则直接使用, 否则去远程仓库下载. 本地仓库:默认地址为~/.m2/, 一个构件只有在本地仓库存在之后, 才能由Maven项目使用. 远程仓库: 远程仓库又可简单分成两类: 中央仓库和私服.由于原始的本地仓库是空的, Maven必须至少知道一个远程仓库才能在执行命令时下载需要的构件, 中央仓库就是这样一个默认的远程仓库. 关于仓库的详细配置可参考: Settings Reference 的 Servers、Mirrors、Profiles 等章节. 1234567891011121314&lt;project &gt; ... &lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;releases&lt;/id&gt; &lt;url&gt;http://mvn.server.com/nexus/content/repositories/releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;url&gt;http://mvn.server.com/nexus/content/repositories/snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;/distributionManagement&gt;&lt;/project&gt; repository表示发布版本构件的仓库, snapshotRepository代表快照版本的仓库. id为该远程仓库唯一标识, url表示该仓库地址. 配置正确后, 执行$ mvn clean deploy则可以将项目构建输出的构件部署到对应配置的远程仓库. 注: 往远程仓库部署构件时, 往往需要认证: 需要在settings.xml中创建servers元素, 其id与仓库的id匹配, 详见: Password Encryption. 生命周期与插件 Maven 将所有项目的构建过程统一抽象成一套生命周期: 项目的清理、初始化、编译、测试、打包、集成测试、验证、部署和站点生成 … 几乎所有项目的构建,都能映射到这一组生命周期上. 但生命周期是抽象的(Maven的生命周期本身是不做任何实际工作), 任务执行(如编译源代码)均交由插件完成. 其中每个构建步骤都可以绑定一个或多个插件的目标,而且Maven为大多数构建步骤都编写并绑定了默认插件.当用户有特殊需要的时候, 也可以配置插件定制构建行为, 甚至自己编写插件. Maven 拥有三套相互独立的生命周期: clean、default 和 site, 而每个生命周期包含一些phase阶段, 阶段是有顺序的, 并且后面的阶段依赖于前面的阶段. 而三套生命周期相互之间却并没有前后依赖关系, 即调用site周期内的某个phase阶段并不会对clean产生任何影响. clean clean生命周期的目的是清理项目: 执行如$ mvn clean; default default生命周期定义了真正构建时所需要执行的所有步骤: 执行如$ mvn clean install; site site生命周期的目的是建立和发布项目站点: Maven能够基于POM所包含的信息,自动生成一个友好的站点,方便团队交流和发布项目信息 执行命令如$ mvn clean deploy site-deploy; 更多 Maven 生命周期介绍可以参考: Introduction to the Build Lifecycle、Lifecycles Reference. 生命周期的阶段phase与插件的目标goal相互绑定, 用以完成实际的构建任务. 而对于插件本身, 为了能够复用代码,它往往能够完成多个任务, 这些功能聚集在一个插件里,每个功能就是一个目标.如:$ mvn compiler:compile冒号前是插件前缀, 后面是该插件目标(即: maven-compiler-plugin的compile目标). 为了能让用户几乎不用任何配置就能使用Maven构建项目, Maven 默认为一些核心的生命周期绑定了插件目标, 当用户通过命令调用生命周期阶段时, 对应的插件目标就会执行相应的逻辑. clean生命周期阶段绑定 生命周期阶段 插件目标 pre-clean - clean maven-clean-plugin:clean post-clean - default声明周期阶段绑定 生命周期阶段 插件目标 执行任务 process-resources maven-resources-plugin:resources 复制主资源文件到主输出目录 compile maven-compiler-plugin:compile 编译主代码到主输出目录 process-test-resources maven-resources-plugin:testResources 复制测试资源文件到测试输出目录 test-compile maven-compiler-plugin:testCompile 编译测试代码到测试输出目录 test maven-surefire-plugin:test 执行测试用例 package maven-jar-plugin:jar 打jar包 install maven-install-plugin:install 将项目输出安装到本地仓库 deploy maven-deploy-plugin:deploy 将项目输出部署到远程仓库 site生命周期阶段绑定 生命周期阶段 插件目标 pre-site - site maven-site-plugin:site post-site - site-deploy maven-site-plugin:deploy 除了内置绑定以外, 用户还能够自定义将某个插件目标绑定到生命周期的某个阶段上. 如创建项目的源码包, maven-source-plugin插件的jar-no-fork目标能够将项目的主代码打包成jar文件, 可以将其绑定到verify阶段上: 123456789101112131415161718&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;attach-sources&lt;/id&gt; &lt;phase&gt;verify&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;jar-no-fork&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; executions下每个execution子元素可以用来配置执行一个任务. 关于Maven插件的自定义绑定及其他详细配置可参考: Guide to Configuring Plug-ins. 模块聚合 Maven的聚合特性(aggregation)能够使项目的多个模块聚合在一起构建, 而继承特性(inheritance)能够帮助抽取各模块相同的依赖、插件等配置,在简化模块配置的同时, 保持各模块一致. 聚合POM 聚合模块POM仅仅是帮助聚合其他模块构建的工具, 本身并无实质内容: 12345678910111213141516171819&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.vdian.feedcenter&lt;/groupId&gt; &lt;artifactId&gt;feedcenter-push&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0.0.SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;feedcenter-push-client&lt;/module&gt; &lt;module&gt;feedcenter-push-core&lt;/module&gt; &lt;module&gt;feedcenter-push-web&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; 通过在一个打包方式为pom的Maven项目中声明任意数量的module以实现模块聚合: packaging: pom, 否则无法聚合构建. modules: 实现聚合的核心,module值为被聚合模块相对于聚合POM的相对路径, 每个被聚合模块下还各自包含有pom.xml、src/main/java、src/test/java等内容, 离开聚合POM也能够独立构建(注: 模块所处目录最好与其artifactId一致). Tips: 推荐将聚合POM放在项目目录的最顶层, 其他模块作为聚合模块的子目录.其他关于聚合与反应堆介绍可参考: Guide to Working with Multiple Modules. 模块继承在面向对象中, 可以通过类继承实现复用. 在Maven中同样也可以创建POM的父子结构, 通过在父POM中声明一些配置供子POM继承来实现复用与消除重复: 与聚合类似, 父POM的打包方式也是pom, 因此可以继续复用聚合模块的POM(这也是在开发中常用的方式): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.vdian.feedcenter&lt;/groupId&gt; &lt;artifactId&gt;feedcenter-push&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0.0.SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;feedcenter-push-client&lt;/module&gt; &lt;module&gt;feedcenter-push-core&lt;/module&gt; &lt;module&gt;feedcenter-push-web&lt;/module&gt; &lt;/modules&gt; &lt;properties&gt; &lt;finalName&gt;feedcenter-push&lt;/finalName&gt; &lt;warName&gt;$&#123;finalName&#125;.war&lt;/warName&gt; &lt;spring.version&gt;4.0.6.RELEASE&lt;/spring.version&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;warExplodedDirectory&gt;exploded/$&#123;warName&#125;&lt;/warExplodedDirectory&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;attach-sources&lt;/id&gt; &lt;phase&gt;verify&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;jar-no-fork&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; dependencyManagement: 能让子POM继承父POM的配置的同时, 又能够保证子模块的灵活性: 在父POM dependencyManagement元素配置的依赖声明不会实际引入子模块中, 但能够约束子模块dependencies下的依赖的使用(子模块只需配置groupId与artifactId, 见下). pluginManagement: 与dependencyManagement类似, 配置的插件不会造成实际插件的调用行为, 只有当子POM中配置了相关plugin元素, 才会影响实际的插件行为. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;groupId&gt;com.vdian.feedcenter&lt;/groupId&gt; &lt;artifactId&gt;feedcenter-push&lt;/artifactId&gt; &lt;version&gt;1.0.0.SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;feedcenter-push-client&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 元素继承 可以看到, 子POM中并未定义模块groupId与version, 这是因为子POM默认会从父POM继承了如下元素: groupId、version dependencies developers and contributors plugin lists (including reports) plugin executions with matching ids plugin configuration resources 优势: 当依赖、插件的版本、配置等信息在父POM中声明之后, 子模块在使用时就无须声明这些信息, 也就不会出现多个子模块使用的依赖版本不一致的情况, 也就降低了依赖冲突的几率. 另外如果子模块不显式声明依赖与插件的使用, 即使已经在父POM的dependencyManagement、pluginManagement中配置了, 也不会产生实际的效果. 推荐: 模块继承与模块聚合同时进行,这意味着, 你可以为你的所有模块指定一个父工程, 同时父工程中可以指定其余的Maven模块作为它的聚合模块. 但需要遵循以下三条规则: 在所有子POM中指定它们的父POM; 将父POM的packaging值设为pom; 在父POM中指定子模块/子POM的目录. 注: parent元素内还包含一个relativePath元素, 用于指定父POM的相对路径, 默认../pom.xml. 任何一个Maven项目都隐式地继承自超级POM, 因此超级POM的大量配置都会被所有的Maven项目继承, 这些配置也成为了Maven所提倡的约定. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135&lt;!-- START SNIPPET: superpom --&gt;&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 定义了中央仓库以及插件仓库, 均为:https://repo.maven.apache.org/maven2 --&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Central Repository&lt;/name&gt; &lt;url&gt;https://repo.maven.apache.org/maven2&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Central Repository&lt;/name&gt; &lt;url&gt;https://repo.maven.apache.org/maven2&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;releases&gt; &lt;updatePolicy&gt;never&lt;/updatePolicy&gt; &lt;/releases&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;!-- 依次定义了各类代码、资源、输出目录及最终构件名称格式, 这就是Maven项目结构的约定 --&gt; &lt;build&gt; &lt;directory&gt;$&#123;project.basedir&#125;/target&lt;/directory&gt; &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/classes&lt;/outputDirectory&gt; &lt;finalName&gt;$&#123;project.artifactId&#125;-$&#123;project.version&#125;&lt;/finalName&gt; &lt;testOutputDirectory&gt;$&#123;project.build.directory&#125;/test-classes&lt;/testOutputDirectory&gt; &lt;sourceDirectory&gt;$&#123;project.basedir&#125;/src/main/java&lt;/sourceDirectory&gt; &lt;scriptSourceDirectory&gt;$&#123;project.basedir&#125;/src/main/scripts&lt;/scriptSourceDirectory&gt; &lt;testSourceDirectory&gt;$&#123;project.basedir&#125;/src/test/java&lt;/testSourceDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;$&#123;project.basedir&#125;/src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;testResources&gt; &lt;testResource&gt; &lt;directory&gt;$&#123;project.basedir&#125;/src/test/resources&lt;/directory&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;!-- 为核心插件设定版本 --&gt; &lt;pluginManagement&gt; &lt;!-- NOTE: These plugins will be removed from future versions of the super POM --&gt; &lt;!-- They are kept for the moment as they are very unlikely to conflict with lifecycle mappings (MNG-4453) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;2.2-beta-5&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;version&gt;2.8&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-release-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt; &lt;!-- 定义项目报告输出路径 --&gt; &lt;reporting&gt; &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/site&lt;/outputDirectory&gt; &lt;/reporting&gt; &lt;!-- 定义release-profile, 为构件附上源码与文档 --&gt; &lt;profiles&gt; &lt;!-- NOTE: The release profile will be removed from future versions of the super POM --&gt; &lt;profile&gt; &lt;id&gt;release-profile&lt;/id&gt; &lt;activation&gt; &lt;property&gt; &lt;name&gt;performRelease&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;/activation&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;inherited&gt;true&lt;/inherited&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;attach-sources&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;inherited&gt;true&lt;/inherited&gt; &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;attach-javadocs&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;inherited&gt;true&lt;/inherited&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;updateReleaseInfo&gt;true&lt;/updateReleaseInfo&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/profile&gt; &lt;/profiles&gt;&lt;/project&gt;&lt;!-- END SNIPPET: superpom --&gt; 附: Maven继承与组合的其他信息还可参考: Introduction to the POM.]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RocketMQ Spring-boot 实现]]></title>
    <url>%2F2018%2F11%2F30%2FRocketMQ-Spring-boot-%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8 函数式]]></title>
    <url>%2F2018%2F11%2F28%2FJava8-%E5%87%BD%E6%95%B0%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Java8 函数式方程Java中重要的函数接口 接口 参数 返回类型 Predicate&lt;T> T boolean Consumer&lt;T> T viod Function&lt;T, R&gt; T R Supplier&lt;T> None T UnaryOperator&lt;T> T T BinaryOperator&lt;T> (T, T) T 常用的流操作 方法 作用 示例 collect(toList()) 生成一个列表 Stream.of(“a”, “b”, “c”).collect(Collectors.toList()); map 将一种类型转换成另外一种类型 Stream.of(“a”, “b”, “c”).map(s -&gt; s.toUpperCase()). collect(Collectors.toList()); filter 过滤数据 Stream.of(“a”, “1”, “b”).filter(v -&gt; isDigit(v.charAt(0))). collect(Collectors.toList()); flatMap 将多个Stream连接成一个Stream Stream.of(asList(1, 2), asList(3, 4)).flatMap(n -&gt; n.stream()).collect(Collectors.toList()); max/min 求最大和最小值 Stream.of(“a”, “ab”, “abc”).max(Comparator.comparing(v -&gt; v.length())).get()); reduce 累加操作 Steam.of(1, 2, 3).reduce(Integer::sum); 补充 Java8 Optional Java8 @FunctionalInterface Stream 原理]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 整理]]></title>
    <url>%2F2018%2F11%2F23%2Fgit-%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[git–整理专用名词1234567Worksapce: 工作区Index/Stage: 暂存区Repository: 仓库区Remote: 远程仓库 新建代码库12345678# 在当前目录新建一个Git代码库git init# 新建一个目录，将其初始化为Git代码库git init [project-name]# 下载一个项目和它的整个代码历史git clone [url] git配置12345678# 显示当前的Git配置git config --list# 编辑Git配置文件git config -e [--global]# 设置提交代码时的用户信息git config --global [core.editor, user.name, user.email, merge.tool。。。。] [value] 添加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录git add [dir]# 添加当前目录的所有文件到暂存区git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交git add -p# 删除工作区文件，并且将这次删除放入暂存区git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区git rm --cached [file]# 改名文件，并且将这个改名放入暂存区git mv [file-original] [file-renamed] 提交代码123456789101112131415161718# 提交暂存区到仓库区git commit -m [message]# 提交暂存区的指定文件到仓库区git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区git commit -a# 提交时显示所有diff信息git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839404142434445# 列出所有本地分支git branch# 列出所有远程分支git branch -r# 列出所有本地分支和远程分支git branch -a# 新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch]# 新建一个分支，指向指定commitgit branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区git checkout [branch-name]# 切换到上一个分支git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支git merge [branch]# 选择一个commit，合并进当前分支git cherry-pick [commit]# 删除分支git branch -d [branch-name]# 删除远程分支git push origin --delete [branch-name]git branch -dr [remote/branch]# 已经（或尚未）与当前分支合并的分支git branch [--merged, --no-merged] 标签1234567891011121314151617181920212223242526# 列出所有taggit tag# 新建一个tag在当前commitgit tag [tag]# 新建一个tag在指定commitgit tag [tag] [commit]# 删除本地taggit tag -d [tag]# 删除远程taggit push origin :refs/tags/[tagName]# 查看tag信息git show [tag]# 提交指定taggit push [remote] [tag]# 提交所有taggit push [remote] --tags# 新建一个分支，指向某个taggit checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件git status# 显示当前分支的版本历史git log# 显示commit历史，以及每次commit发生变更的文件git log --stat# 搜索提交历史，根据关键词git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名git log --follow [file]git whatchanged [file]# 显示指定文件相关的每一次diffgit log -p [file]# 显示过去5次提交git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序git shortlog -sn# 显示指定文件是什么人在什么时间修改过git blame [file]# 显示暂存区和工作区的差异git diff# 显示暂存区和上一个commit的差异git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异git diff HEAD# 显示两次提交之间的差异git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化git show [commit]# 显示某次提交发生变化的文件git show --name-only [commit]# 显示某次提交时，某个文件的内容git show [commit]:[filename]# 显示当前分支的最近几次提交git reflog 远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动git fetch [remote]# 显示所有远程仓库git remote -v# 显示某个远程仓库的信息git remote show [remote]# 增加一个新的远程仓库，并命名git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并git pull [remote] [branch]# 上传本地指定分支到远程仓库git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突git push [remote] --force# 推送所有分支到远程仓库git push [remote] --all 撤销12345678910111213141516171819202122232425262728293031323334# 恢复暂存区的指定文件到工作区git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区git checkout [commit] [file]# 恢复暂存区的所有文件到工作区git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变git reset [file]# 重置暂存区与工作区，与上一次commit保持一致git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支git revert [commit]# 暂时将未提交的变化移除，稍后再移入git stashgit stash pop# 取消暂存git reset HEAD &lt;file&gt; 其他12345# 可视化的合并工具git mergetool# 生成一个可供发布的压缩包git archive]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring事务传播机制]]></title>
    <url>%2F2018%2F11%2F13%2FSpring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Spring事务传播机制 Spring在TransactionDefinition接口中规定了7种类型的事务传播行为，它们规定了事务方法和事务方法发生嵌套调用时事务如何进行传播，即协调已经有事务标识的方法之间的发生调用时事务上下文规则（是否要有独立的事务隔离级别和锁） 事务传播行为种类 事务传播行为类型 说明 PROPAGATION_REQUIRED 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。 PROPAGATION_SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式执行。 PROPAGATION_MANDATORY 使用当前的事务，如果当前没有事务，就抛出异常。 PROPAGATION_REQUIRES_NEW 新建事务，如果当前存在事务，把当前事务挂起。 PROPAGATION_NOT_SUPPORTED 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 PROPAGATION_NEVER 以非事务方式执行，如果当前存在事务，则抛出异常。 PROPAGATION_NESTED 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。 当使用PROPAGATION_NESTED时，底层的数据源必须基于JDBC 3.0，并且实现者需要支持保存点事务机制。]]></content>
      <categories>
        <category>Transaction</category>
      </categories>
      <tags>
        <tag>事务</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务隔离级别]]></title>
    <url>%2F2018%2F11%2F12%2F%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%2F</url>
    <content type="text"><![CDATA[MySQL–事务（Transaction）事务的基本要素（ACID） 原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就想没有发生一样。也就是说事务是一个不可分割的整体。 一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没有收到。 隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程中，B不能向这张卡转账。 持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。 事务的并发问题 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据。 不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。 幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。 小结：不可重复读和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增和删除。解决不可重复读的问题只需要锁住满足条件的行，解决幻读需要锁表。 MySQL事务隔离级别 事务隔离级别 脏读 不可重复读 幻读 读未提交（read uncommitted） 是 是 是 读已提交（read committed） 否 是 是 可重复读（repeatable read） 否 否 是（mysql-InnoDB 否） 串性化（serializable） 否 否 否 read uncommitted： 123- 事务A和事务B，事务A未提交的数据，事务B可以读取到- 这里读取到的数据叫做“脏数据”- 这种隔离级别最低，这种级别一般是在理论上存在，数据库隔离级别一般都高于该级别 read committed： 123456- 事物A和事物B，事物A提交的数据，事物B才能读取到- 这种隔离级别高于读未提交- 换句话说，对方事物提交之后的数据，我当前事物才能读取到- 这种级别可以避免“脏数据”- 这种隔离级别会导致“不可重复读取”- Oracle默认隔离级别 repeatable read： 123456789- 事务A和事务B，事务A提交之后的数据，事务B读取不到- 事务B是可重复读取数据- 这种隔离级别高于读已提交- 换句话说，对方提交之后的数据，我还是读取不到- 这种隔离级别可以避免“不可重复读取”，达到可重复读取- 比如1点和2点读到数据是同一个- MySQL默认级别- 虽然可以达到可重复读取，但是会导致“幻像读”- 可重复读的隔离级别下使用了MVCC机制，select操作不会更新版本号，是快照读（历史版本）；insert、update和delete会更新版本号，是当前读（当前版本）。 serializable： 123- 事务A和事务B，事务A在操作数据库时，事务B只能排队等待- 这种隔离级别很少使用，吞吐量太低，用户体验差- 这种级别可以避免“幻像读”，每一次读取的都是数据库中真实存在数据，事务A与事务B串行，而不并发 基本操作1234- 查询当前事务级别mysql&gt; select @@tx_isolation;- 设置隔离级别SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL &lt;isolation-level&gt; 补充 事务隔离级别为读提交时，写数据只会锁住相应的行 事务隔离级别为可重复读时，如果检索条件有索引（包括主键索引）的时候，默认加锁方式是next-key锁；如果检索条件没有索引，更新数据时会锁住整张表。一个间隙被事务加了锁，其他事务是不能在这个间隙插入记录的，这样可以防止幻读。 事务隔离级别为串行化时，读写数据都会锁住整张表。 隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。 MySQL MVCCC实现机制 关于next-key锁]]></content>
      <categories>
        <category>Transaction</category>
      </categories>
      <tags>
        <tag>事务</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
