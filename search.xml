<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[markdown-整理]]></title>
    <url>%2F2018%2F12%2F24%2Fmarkdown-%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Markdown – 整理一 、标题1234567891011121. 最高阶标题This is an H1=============2. 第二阶标题This is an H2-------------3. 用#表示阶数（只有1-6阶）# 这是 H1## 这是 H2###### 这是 H6 1. This is an H12. This is an H23. 这是 H1这是 H2这是 H6 二 、引用1234567891011&gt;这是引用&gt;引用名人名言之类的呀&gt;&gt;也可以嵌套引用&gt; ## 这是一个标题。&gt;&gt; 1. 这是第一行列表项。&gt; 2. 这是第二行列表项。&gt;&gt; 给出一些例子代码：&gt;&gt; return shell_exec("echo $input | $markdown_script"); 这是引用引用名人名言之类的呀 也可以嵌套引用 这是一个标题。 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(&quot;echo $input | $markdown_script&quot;); 三 、列表12345678910111213141516171819* Red - asd - ead - sada - asd* Green* Blue1. Bird 1. sadaasd 中间也可以插入其他标签 2. sadaasd 3. asdas 4. asdas 1. asdas 2. asdas2. McHale3. Parish Red asd ead sada asd Green Blue Bird sadaasd 1中间也可以插入其他标签 sadaasd asdas asdas asdas asdas McHale Parish 四 、分隔线123456789* * *********- - ---------------------------------------- 五 、 链接/图片123456789101112131415161718This is [an example](http://example.com/ "Title") inline link.[This link](http://example.net/) has no title attribute.[foo]: http://example.com/ "Optional Title Here"[自定义链接] [id][id]: http://example.com/ "Optional Title Here"![Alt text](/markdown-整理/img.png)![Alt text](/markdown-整理/img.png "Optional title")![Alt text][idpig][idpig]: /markdown-整理/img.pnge "Optional title attribute" This is an example inline link. This link has no title attribute. 自定义链接 六 、 强调123456789*single asterisks***double asterisks*****three asterisks***\*this text is surrounded by literal asterisks\*~~这样~~ single asterisks double asterisks three asterisks *this text is surrounded by literal asterisks* 这样 七 、 代码123456789Use the `printf()` function.``There is a literal backtick (`) here.``A single backtick in a code span: `` ` ``A backtick-delimited string in a code span: `` `foo` ``Please don't use any `&lt;blink&gt;` tags. Use the printf() function. There is a literal backtick (`) here. A single backtick in a code span: ` A backtick-delimited string in a code span: `foo` Please don’t use any &lt;blink&gt; tags. 八 、 选项123- [x] 这是选中的复选框` ‘-’ + ‘空格’ + ‘[中间有空格]’ `- [ ] 这是未选中的复选框` ‘-’ + ‘空格’ + ‘[中间有空格]’ ` [x] 这是选中的复选框‘-’ + ‘空格’ + ‘[中间有空格]’ [ ] 这是未选中的复选框‘-’ + ‘空格’ + ‘[中间有空格]’ 九 、 表格1234| a | b | c ||:-------:|:------------- | ----------:|| 居中 | 左对齐 | 右对齐 ||=========|===============|============| a b c 居中 左对齐 右对齐 ========= =============== ============ 十 、 不兼容的12345678# 脚注 Footnote这就是一个脚注:[^sample_footnote]# MarkDown的标注&lt;!-- comment --&gt;# 自动生成目录 TOC[TOC]]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux 整理]]></title>
    <url>%2F2018%2F11%2F30%2FLinux-%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Maven 整理]]></title>
    <url>%2F2018%2F11%2F30%2FMaven-%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[RocketMQ Spring-boot 实现]]></title>
    <url>%2F2018%2F11%2F30%2FRocketMQ-Spring-boot-%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java8 函数式]]></title>
    <url>%2F2018%2F11%2F28%2FJava8-%E5%87%BD%E6%95%B0%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Java8 函数式方程Java中重要的函数接口 接口 参数 返回类型 Predicate&lt;T> T boolean Consumer&lt;T> T viod Function&lt;T, R&gt; T R Supplier&lt;T> None T UnaryOperator&lt;T> T T BinaryOperator&lt;T> (T, T) T 常用的流操作 方法 作用 示例 collect(toList()) 生成一个列表 Stream.of(“a”, “b”, “c”).collect(Collectors.toList()); map 将一种类型转换成另外一种类型 Stream.of(“a”, “b”, “c”).map(s -&gt; s.toUpperCase()). collect(Collectors.toList()); filter 过滤数据 Stream.of(“a”, “1”, “b”).filter(v -&gt; isDigit(v.charAt(0))). collect(Collectors.toList()); flatMap 将多个Stream连接成一个Stream Stream.of(asList(1, 2), asList(3, 4)).flatMap(n -&gt; n.stream()).collect(Collectors.toList()); max/min 求最大和最小值 Stream.of(“a”, “ab”, “abc”).max(Comparator.comparing(v -&gt; v.length())).get()); reduce 累加操作 Steam.of(1, 2, 3).reduce(Integer::sum); 补充 Java8 Optional Java8 @FunctionalInterface Stream 原理]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 整理]]></title>
    <url>%2F2018%2F11%2F23%2Fgit-%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[git–整理专用名词1234567Worksapce: 工作区Index/Stage: 暂存区Repository: 仓库区Remote: 远程仓库 新建代码库12345678# 在当前目录新建一个Git代码库git init# 新建一个目录，将其初始化为Git代码库git init [project-name]# 下载一个项目和它的整个代码历史git clone [url] git配置12345678# 显示当前的Git配置git config --list# 编辑Git配置文件git config -e [--global]# 设置提交代码时的用户信息git config --global [core.editor, user.name, user.email, merge.tool。。。。] [value] 添加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录git add [dir]# 添加当前目录的所有文件到暂存区git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交git add -p# 删除工作区文件，并且将这次删除放入暂存区git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区git rm --cached [file]# 改名文件，并且将这个改名放入暂存区git mv [file-original] [file-renamed] 提交代码123456789101112131415161718# 提交暂存区到仓库区git commit -m [message]# 提交暂存区的指定文件到仓库区git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区git commit -a# 提交时显示所有diff信息git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839404142434445# 列出所有本地分支git branch# 列出所有远程分支git branch -r# 列出所有本地分支和远程分支git branch -a# 新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch]# 新建一个分支，指向指定commitgit branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区git checkout [branch-name]# 切换到上一个分支git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支git merge [branch]# 选择一个commit，合并进当前分支git cherry-pick [commit]# 删除分支git branch -d [branch-name]# 删除远程分支git push origin --delete [branch-name]git branch -dr [remote/branch]# 已经（或尚未）与当前分支合并的分支git branch [--merged, --no-merged] 标签1234567891011121314151617181920212223242526# 列出所有taggit tag# 新建一个tag在当前commitgit tag [tag]# 新建一个tag在指定commitgit tag [tag] [commit]# 删除本地taggit tag -d [tag]# 删除远程taggit push origin :refs/tags/[tagName]# 查看tag信息git show [tag]# 提交指定taggit push [remote] [tag]# 提交所有taggit push [remote] --tags# 新建一个分支，指向某个taggit checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件git status# 显示当前分支的版本历史git log# 显示commit历史，以及每次commit发生变更的文件git log --stat# 搜索提交历史，根据关键词git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名git log --follow [file]git whatchanged [file]# 显示指定文件相关的每一次diffgit log -p [file]# 显示过去5次提交git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序git shortlog -sn# 显示指定文件是什么人在什么时间修改过git blame [file]# 显示暂存区和工作区的差异git diff# 显示暂存区和上一个commit的差异git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异git diff HEAD# 显示两次提交之间的差异git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化git show [commit]# 显示某次提交发生变化的文件git show --name-only [commit]# 显示某次提交时，某个文件的内容git show [commit]:[filename]# 显示当前分支的最近几次提交git reflog 远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动git fetch [remote]# 显示所有远程仓库git remote -v# 显示某个远程仓库的信息git remote show [remote]# 增加一个新的远程仓库，并命名git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并git pull [remote] [branch]# 上传本地指定分支到远程仓库git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突git push [remote] --force# 推送所有分支到远程仓库git push [remote] --all 撤销12345678910111213141516171819202122232425262728293031323334# 恢复暂存区的指定文件到工作区git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区git checkout [commit] [file]# 恢复暂存区的所有文件到工作区git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变git reset [file]# 重置暂存区与工作区，与上一次commit保持一致git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支git revert [commit]# 暂时将未提交的变化移除，稍后再移入git stashgit stash pop# 取消暂存git reset HEAD &lt;file&gt; 其他12345# 可视化的合并工具git mergetool# 生成一个可供发布的压缩包git archive]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring事务传播机制]]></title>
    <url>%2F2018%2F11%2F13%2FSpring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Spring事务传播机制 Spring在TransactionDefinition接口中规定了7种类型的事务传播行为，它们规定了事务方法和事务方法发生嵌套调用时事务如何进行传播，即协调已经有事务标识的方法之间的发生调用时事务上下文规则（是否要有独立的事务隔离级别和锁） 事务传播行为种类 事务传播行为类型 说明 PROPAGATION_REQUIRED 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。 PROPAGATION_SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式执行。 PROPAGATION_MANDATORY 使用当前的事务，如果当前没有事务，就抛出异常。 PROPAGATION_REQUIRES_NEW 新建事务，如果当前存在事务，把当前事务挂起。 PROPAGATION_NOT_SUPPORTED 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 PROPAGATION_NEVER 以非事务方式执行，如果当前存在事务，则抛出异常。 PROPAGATION_NESTED 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。 当使用PROPAGATION_NESTED时，底层的数据源必须基于JDBC 3.0，并且实现者需要支持保存点事务机制。]]></content>
      <categories>
        <category>Transaction</category>
      </categories>
      <tags>
        <tag>事务</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务隔离级别]]></title>
    <url>%2F2018%2F11%2F12%2F%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%2F</url>
    <content type="text"><![CDATA[MySQL–事务（Transaction）事务的基本要素（ACID） 原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就想没有发生一样。也就是说事务是一个不可分割的整体。 一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没有收到。 隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程中，B不能向这张卡转账。 持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。 事务的并发问题 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据。 不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。 幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。 小结：不可重复读和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增和删除。解决不可重复读的问题只需要锁住满足条件的行，解决幻读需要锁表。 MySQL事务隔离级别 事务隔离级别 脏读 不可重复读 幻读 读未提交（read uncommitted） 是 是 是 读已提交（read committed） 否 是 是 可重复读（repeatable read） 否 否 是（mysql-InnoDB 否） 串性化（serializable） 否 否 否 read uncommitted： 123- 事务A和事务B，事务A未提交的数据，事务B可以读取到- 这里读取到的数据叫做“脏数据”- 这种隔离级别最低，这种级别一般是在理论上存在，数据库隔离级别一般都高于该级别 read committed： 123456- 事物A和事物B，事物A提交的数据，事物B才能读取到- 这种隔离级别高于读未提交- 换句话说，对方事物提交之后的数据，我当前事物才能读取到- 这种级别可以避免“脏数据”- 这种隔离级别会导致“不可重复读取”- Oracle默认隔离级别 repeatable read： 123456789- 事务A和事务B，事务A提交之后的数据，事务B读取不到- 事务B是可重复读取数据- 这种隔离级别高于读已提交- 换句话说，对方提交之后的数据，我还是读取不到- 这种隔离级别可以避免“不可重复读取”，达到可重复读取- 比如1点和2点读到数据是同一个- MySQL默认级别- 虽然可以达到可重复读取，但是会导致“幻像读”- 可重复读的隔离级别下使用了MVCC机制，select操作不会更新版本号，是快照读（历史版本）；insert、update和delete会更新版本号，是当前读（当前版本）。 serializable： 123- 事务A和事务B，事务A在操作数据库时，事务B只能排队等待- 这种隔离级别很少使用，吞吐量太低，用户体验差- 这种级别可以避免“幻像读”，每一次读取的都是数据库中真实存在数据，事务A与事务B串行，而不并发 基本操作1234- 查询当前事务级别mysql&gt; select @@tx_isolation;- 设置隔离级别SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL &lt;isolation-level&gt; 补充 事务隔离级别为读提交时，写数据只会锁住相应的行 事务隔离级别为可重复读时，如果检索条件有索引（包括主键索引）的时候，默认加锁方式是next-key锁；如果检索条件没有索引，更新数据时会锁住整张表。一个间隙被事务加了锁，其他事务是不能在这个间隙插入记录的，这样可以防止幻读。 事务隔离级别为串行化时，读写数据都会锁住整张表。 隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。 MySQL MVCCC实现机制 关于next-key锁]]></content>
      <categories>
        <category>Transaction</category>
      </categories>
      <tags>
        <tag>事务</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
