<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring事务传播机制]]></title>
    <url>%2F2018%2F11%2F13%2FSpring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Spring事务传播机制 Spring在TransactionDefinition接口中规定了7种类型的事务传播行为，它们规定了事务方法和事务方法发生嵌套调用时事务如何进行传播，即协调已经有事务标识的方法之间的发生调用时事务上下文规则（是否要有独立的事务隔离级别和锁） 事务传播行为种类 事务传播行为类型 说明 PROPAGATION_REQUIRED 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。 PROPAGATION_SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式执行。 PROPAGATION_MANDATORY 使用当前的事务，如果当前没有事务，就抛出异常。 PROPAGATION_REQUIRES_NEW 新建事务，如果当前存在事务，把当前事务挂起。 PROPAGATION_NOT_SUPPORTED 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 PROPAGATION_NEVER 以非事务方式执行，如果当前存在事务，则抛出异常。 PROPAGATION_NESTED 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。 当使用PROPAGATION_NESTED时，底层的数据源必须基于JDBC 3.0，并且实现者需要支持保存点事务机制。]]></content>
      <categories>
        <category>Transaction</category>
      </categories>
      <tags>
        <tag>事务</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务隔离级别]]></title>
    <url>%2F2018%2F11%2F12%2F%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%2F</url>
    <content type="text"><![CDATA[MySQL–事务（Transaction）事务的基本要素（ACID） 原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就想没有发生一样。也就是说事务是一个不可分割的整体。 一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没有收到。 隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程中，B不能向这张卡转账。 持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。 事务的并发问题 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据。 不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。 幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。 小结：不可重复读和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增和删除。解决不可重复读的问题只需要锁住满足条件的行，解决幻读需要锁表。 MySQL事务隔离级别 事务隔离级别 脏读 不可重复读 幻读 读未提交（read uncommitted） 是 是 是 读已提交（read committed） 否 是 是 可重复读（repeatable read） 否 否 是（mysql-InnoDB 否） 串性化（serializable） 否 否 否 read uncommitted： 123- 事务A和事务B，事务A未提交的数据，事务B可以读取到- 这里读取到的数据叫做“脏数据”- 这种隔离级别最低，这种级别一般是在理论上存在，数据库隔离级别一般都高于该级别 read committed： 123456- 事物A和事物B，事物A提交的数据，事物B才能读取到- 这种隔离级别高于读未提交- 换句话说，对方事物提交之后的数据，我当前事物才能读取到- 这种级别可以避免“脏数据”- 这种隔离级别会导致“不可重复读取”- Oracle默认隔离级别 repeatable read： 123456789- 事务A和事务B，事务A提交之后的数据，事务B读取不到- 事务B是可重复读取数据- 这种隔离级别高于读已提交- 换句话说，对方提交之后的数据，我还是读取不到- 这种隔离级别可以避免“不可重复读取”，达到可重复读取- 比如1点和2点读到数据是同一个- MySQL默认级别- 虽然可以达到可重复读取，但是会导致“幻像读”- 可重复读的隔离级别下使用了MVCC机制，select操作不会更新版本号，是快照读（历史版本）；insert、update和delete会更新版本号，是当前读（当前版本）。 serializable： 123- 事务A和事务B，事务A在操作数据库时，事务B只能排队等待- 这种隔离级别很少使用，吞吐量太低，用户体验差- 这种级别可以避免“幻像读”，每一次读取的都是数据库中真实存在数据，事务A与事务B串行，而不并发 基本操作1234- 查询当前事务级别mysql&gt; select @@tx_isolation;- 设置隔离级别SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL &lt;isolation-level&gt; 补充 事务隔离级别为读提交时，写数据只会锁住相应的行 事务隔离级别为可重复读时，如果检索条件有索引（包括主键索引）的时候，默认加锁方式是next-key锁；如果检索条件没有索引，更新数据时会锁住整张表。一个间隙被事务加了锁，其他事务是不能在这个间隙插入记录的，这样可以防止幻读。 事务隔离级别为串行化时，读写数据都会锁住整张表。 隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。 MySQL MVCCC实现机制 关于next-key锁]]></content>
      <categories>
        <category>Transaction</category>
      </categories>
      <tags>
        <tag>事务</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
